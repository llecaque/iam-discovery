# -*- coding: utf-8 -*-
"""
GDPR Access Audit Using a Pre-built IAM Cache.

This script performs an audit for a list of users provided either from a CSV file
or a Google Group. The audit process is:
1.  **Google Workspace:** Identifies the users to audit and finds all their Google Group memberships.
2.  **Local IAM Cache:** Looks up the GCP project roles for the user and each of their
    groups in a pre-compiled 'iam_cache.json' file.

This approach avoids making live calls to the GCP Asset Inventory API, thus bypassing
API quotas and speeding up the process significantly.

Prerequisites:
- An 'iam_cache.json' file generated by the 'create_iam_cache.py' script.
- Python 3.7+
- Google Workspace client library: pip install --upgrade google-api-python-client google-auth-httplib2 google-auth-oauthlib
- Google Cloud SDK (gcloud CLI) installed and configured.

Setup for Local Testing:
1. Make sure you have the gcloud CLI installed and authenticated.
2. Create Application Default Credentials (ADC) with Workspace scopes:
   gcloud auth application-default login --scopes=https://www.googleapis.com/auth/admin.directory.user.readonly,https://www.googleapis.com/auth/admin.directory.group.readonly,https://www.googleapis.com/auth/admin.directory.group.member.readonly

3. Enable the Admin SDK API in your GCP project:
   gcloud services enable admin.googleapis.com

4. Run the script from your terminal using one of the two modes:
   - By CSV: python this_script_name.py --users-csv /path/to/users.csv
   - By Group: python this_script_name.py --group-email group@example.com
"""
import os
import csv
import argparse
import json
import google.auth
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError

# --- CONFIGURATION ---

SCOPES = [
    'https://www.googleapis.com/auth/admin.directory.user.readonly',
    'https://www.googleapis.com/auth/admin.directory.group.readonly',
    'https://www.googleapis.com/auth/admin.directory.group.member.readonly',
]
IAM_CACHE_PATH = 'iam_cache.json'

# --- SCRIPT LOGIC ---

def get_gws_service():
    """Builds the Google Workspace Admin SDK service object."""
    try:
        creds, _ = google.auth.default(scopes=SCOPES)
        service = build('admin', 'directory_v1', credentials=creds)
        return service
    except Exception as e:
        print(f"ERROR: Could not build Google Workspace service: {e}")
        return None

def read_users_from_csv(file_path):
    """Reads user names from a CSV file."""
    if not os.path.exists(file_path):
        print(f"ERROR: Input CSV file not found at '{file_path}'")
        return None
    users_to_find = []
    try:
        with open(file_path, mode='r', encoding='utf-8') as infile:
            reader = csv.DictReader(infile)
            if 'FirstName' not in reader.fieldnames or 'LastName' not in reader.fieldnames:
                print("ERROR: CSV must contain 'FirstName' and 'LastName' columns.")
                return None
            for row in reader:
                users_to_find.append({'FirstName': row['FirstName'], 'LastName': row['LastName']})
        print(f"Successfully read {len(users_to_find)} users from '{file_path}'.")
        return users_to_find
    except Exception as e:
        print(f"An error occurred reading the CSV file: {e}")
        return None

def find_user_email(service, first_name, last_name):
    """Finds a user's primary email by their first and last name."""
    try:
        query = f"givenName:'{first_name}' familyName:'{last_name}'"
        results = service.users().list(query=query, customer='my_customer', maxResults=2, fields='users(primaryEmail)').execute()
        users = results.get('users', [])
        if len(users) == 1:
            return users[0].get('primaryEmail')
        else:
            print(f"  INFO: Could not find a unique user for {first_name} {last_name}. Skipping.")
            return None
    except HttpError as error:
        print(f"  ERROR: An API error occurred searching for {first_name} {last_name}: {error}")
        return None
    except TimeoutError:
        print(f"  ERROR: A network timeout occurred while searching for {first_name} {last_name}. Skipping.")
        return None

def get_all_group_members(service, group_key):
    """Fetches all members from a given Google Group."""
    members = []
    page_token = None
    try:
        while True:
            results = service.members().list(
                groupKey=group_key,
                pageToken=page_token,
                fields='nextPageToken,members(email,id,type)'
            ).execute()
            
            group_members = results.get('members', [])
            if group_members:
                members.extend([m for m in group_members if m.get('type') == 'USER'])

            page_token = results.get('nextPageToken')
            if not page_token:
                break
        print(f"Found {len(members)} user members in group '{group_key}'.")
        return members
    except HttpError as error:
        print(f"An error occurred fetching group members for '{group_key}': {error}")
        return []
    except TimeoutError:
        print(f"  ERROR: A network timeout occurred while fetching members for group '{group_key}'.")
        return []

def get_groups_for_user(service, user_key):
    """Retrieves all groups a specific user is a member of."""
    try:
        results = service.groups().list(userKey=user_key, fields='groups(name,email)').execute()
        return results.get('groups', [])
    except HttpError as error:
        print(f"  ERROR fetching groups for {user_key}: {error}")
        return []
    except TimeoutError:
        print(f"  ERROR: A network timeout occurred while fetching groups for {user_key}. Skipping.")
        return []


def load_iam_cache(cache_path):
    """Loads the IAM permissions cache from a JSON file."""
    if not os.path.exists(cache_path):
        print(f"ERROR: IAM cache file not found at '{cache_path}'")
        print("Please run the 'create_iam_cache.py' script first.")
        return None
    try:
        with open(cache_path, 'r', encoding='utf-8') as f:
            print(f"Loading IAM cache from '{cache_path}'...")
            return json.load(f)
    except json.JSONDecodeError:
        print(f"ERROR: Could not decode JSON from '{cache_path}'. The file may be corrupt.")
        return None

def get_permissions_from_cache(identity_email, cache_type, iam_cache):
    """Looks up permissions for a user or group in the cache and formats them."""
    report_lines = []
    permissions = iam_cache.get(cache_type, {}).get(identity_email)

    if not permissions:
        report_lines.append("  -> No GCP access found in cache.")
        return "\n".join(report_lines)

    for perm in permissions:
        report_lines.append(f"\n  Project: {perm.get('project')}")
        report_lines.append(f"    - Role: {perm.get('role')}")
    
    return "\n".join(report_lines)

def main():
    """Main function to orchestrate the audit process."""
    parser = argparse.ArgumentParser(description='GDPR Access Audit using a pre-built IAM cache.')
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("--users-csv", help='Path to the input CSV file with FirstName and LastName columns.')
    group.add_argument("--group-email", help='Email address of a Google Group to audit its members.')
    
    args = parser.parse_args()

    # Create output directory
    output_dir = "audit"
    os.makedirs(output_dir, exist_ok=True)
    print(f"Audit reports will be saved in the '{output_dir}/' directory.")

    # Load the IAM cache
    iam_cache = load_iam_cache(IAM_CACHE_PATH)
    if not iam_cache:
        return

    # Initialize Workspace service
    gws_service = get_gws_service()
    if not gws_service:
        return

    # --- Determine list of users to process based on mode ---
    users_to_audit = []
    if args.users_csv:
        users_from_csv = read_users_from_csv(args.users_csv)
        if not users_from_csv:
            return
        for user_info in users_from_csv:
            email = find_user_email(gws_service, user_info['FirstName'], user_info['LastName'])
            if email:
                users_to_audit.append({'email': email, 'FirstName': user_info['FirstName'], 'LastName': user_info['LastName']})
    
    elif args.group_email:
        members = get_all_group_members(gws_service, args.group_email)
        for member in members:
            users_to_audit.append({'email': member.get('email'), 'FirstName': None, 'LastName': None})

    print("\n--- Starting Audit from Cache ---")
    for user_data in users_to_audit:
        user_email = user_data['email']
        first_name = user_data.get('FirstName')
        last_name = user_data.get('LastName')

        if not user_email:
            continue

        # Determine filename and display name
        if first_name and last_name:
            display_name = f"{first_name} {last_name} ({user_email})"
            report_filename = f"{first_name}_{last_name}.txt"
        else:
            display_name = user_email
            report_filename = f"{user_email.split('@')[0]}.txt"
        
        print(f"\nProcessing user: {display_name}")
        
        report_filepath = os.path.join(output_dir, report_filename)
        
        with open(report_filepath, 'w', encoding='utf-8') as f:
            f.write(f"Access Report for: {display_name}\n")
            f.write("="*60 + "\n")

            # 1. Look up user's direct GCP access in the cache
            f.write("\n1. Direct GCP Access (from cache)\n")
            f.write("----------------------------------\n")
            user_access_report = get_permissions_from_cache(user_email, "users", iam_cache)
            f.write(user_access_report)
            f.write("\n")

            # 2. Get user's groups and look up their GCP access in the cache
            f.write("\n2. Inherited GCP Access via Google Groups (from cache)\n")
            f.write("-----------------------------------------------------\n")
            user_groups = get_groups_for_user(gws_service, user_email)

            if not user_groups:
                f.write("User is not a member of any Google Groups.\n")
            else:
                for group in user_groups:
                    group_email = group.get('email')
                    group_name = group.get('name')
                    f.write(f"\nAccess for Group: '{group_name}' ({group_email})\n")
                    
                    group_access_report = get_permissions_from_cache(group_email, "groups", iam_cache)
                    f.write(group_access_report)
                    f.write("\n")
        
        print(f"  -> Report saved to: {report_filepath}")

    print("\n--- Audit Complete ---")

if __name__ == '__main__':
    main()
